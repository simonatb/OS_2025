# Pipes
- stdin (стандартен вход) - програмата чете входни данни от него
- stdout (стандартен изход) - програмата записва изходни данни в него
- stderr (стандартен изход за грешки) - програмата изписва съобщения
към потребителя в него

## Command substitution 
С конструкцията \$\(\<команда\>\) може да вложим изхода на една команда в
друга команда
- Вложената команда се изпълнява и $(...) се заменя с цялото
съдържание на стандартния ѝ изход
- Ако искаме резултатът от изпълнението на вложената команда да се
интерпретира като един цял низ, вместо да се раздели по интервали,
трябва да използваме кавички
- Това е случай, в който ни трябват двойни кавички вместо единични: не
искаме да екранираме значението на $
>find / -type f -user $(whoami)

## Пренасочване
Можем да пренасочваме към файлове

**my_cmd > my_file**

 - \> пренасочва stdout на my_cmd във файла my_file
 - 1\> пренасочва stdout на my_cmd във файла my_file
 - 2\> пренасочва stderr на my_cmd във файла my_file
 - &\> пренасочва stdout и stderr на my_cmd във файла my_file
   
**my_cmd < my_file**

 - пренасочва файла my_file към stdin на my_cmd
   
**find / -type f -name nginx.conf 2>/dev/null**

 - така игнорираме грешките, които find изписва на stderr
 - виртуалният файл /dev/null игнорира всички данни, пратени в него

### Пренасочване на поток в поток
**my_cmd 2>&1 1>/dev/null**
- stdout се пренасочва в /dev/null а stderr се
пренасочва в stdout

**my_cmd 1>/dev/null 2>&1**
- stderr се пренасочва в stdout, който вече е
пренасочен в /dev/null: и двете отиват в /dev/null

**my_cmd 3>&1 1>&2 2>&3**
- разменяме stdout и stderr

### Пренасочване с append
По подразбиране, пренасочването с > презаписва файла, ако той
съществува
- Ако използваме >> вместо >, пренасочването става след края на файла,
ако той съществува
```
$ echo foo > file
$ echo bar >> file
$ rm -f /etc/passwd 2>> file
$ cat file
foo
bar
```
## Работа с текст
### cat \<файл1\> \<файл2\> ...
- конкатенира съдържанията на
подадените файлове
### paste \<файл1\> \<файл2\> ...
- отпечатва редовете на файловете един
до друг паралелно, така че да образуват колонки
- разделителят по подразбиране е TAB
- можем да го сменим с -d
### wc - брои:
- байтове ($ wc -c)
- символи ($ wc -m)
- редове ($ wc -l)
- думи ($ wc -w)
### tr - чете текст от stdin, прави някаква операция със символите в него и извежда резултата на stdout
```
echo 'foo' | tr f b
boo

echo 'i am screaming' | tr a-z A-Z
I AM SCREAMING

echo 'socialism CAPITALISM' | tr -d a-z
CAPITALISM // deletes with -d
```
- squeeze - полезна, ако имаме много празни пространства
```
who
human tty1 2023-03-02 17:41

who | tr -s ' '
human tty1 2023-03-02 17:41
```
### cut -  разглежда текста ред по ред и отрязва специфични колонки
```
sort - сортирай редовете по азбучен ред
-r // сортирай редовете по азбучен ред,
наобратно
-n // приеми, че всеки ред започва с число, и
ги сортирай по числата
-h // приеми, че всеки ред започва с число със
SI суфикс (k, m, g), и ги сортирай по числата
-k // sort via a key; KEYDEF gives location and type
-t // separator
```
**cat some_file | sort -k 2,5** 
- сортирай първо по втората колонка
и после по петата

**cat some_file | sort -t ',' -k 2,5** 
- сортирай първо по втората
колонка и после по петата, приемайки, че колонките са разделени със
запетайки

**cat some_file | sort -r -k 2** 
- сортирай по втората колонка,
наобратно

### uniq - свежда групи от последователни еднакви редове до едно копие на съответния ред
- c - показва брой срещания на всеки ред
### comm \<файл1\> \<файл2\> извежда 3 колонки, съдържащи:
- Редовете, които се срещат само в първия файл
- Редовете, които се срещат само във втория файл
- Редовете, които се срещат и в двата файла
- comm работи само върху сортирани файлове
```
-1 - премахва колоната с редовете само в първия файл
-2 - премахва колоната с редовете само във втория файл
-3 - премахва колоната с общите редове
```
### join - работи само върху сортирани файлове, съединява редовете в двата файла по общи стойности в дадена колонка
## Grep - използва се за търсене в текст

**grep \<низ\> \<файл\>** 
- извежда само редовете от файла, които съдържат
подадения низ
**cat my_file | grep \<низ\>**
- когато не е подаден файл като
аргумент, $ grep чете от stdin
```
-n \\отпечатва и номера на редовете
-B (before), -A (after) и -C (context) \\карат grep да отпечатвa
зададен брой редове преди/след тези, които съдържат търсения низ
-i \\ignore case
-v \\inverts ;намира редовете, които
не съдържат търсения низ
-F \\ кара grep да търси редовете, буквално съдържащи
подадения низ
```
**grep -r \<низ\> \<директория\>**
- търси файлове, съдържащи подадения низ, рекурсивно в подадената директория
