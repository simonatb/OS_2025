# Работа с процеси #
### Вилици ###
- При стартиране на операционната система, тя създава един процес, който изпълнява програма, наречена init
  - има различни програми, които могат да изпълняват ролята на init
- Всички други процеси се стартират с механизъм, наречен fork
  - при fork на процес, той се разделя на две копия: родител и дете
  - контекстът се копира, а не се споделя30
- init програмата има ролята да стартира всички други, програми, които са нужни за работата на операционната система, използвайки fork
- Всички процеси образуват дърво с корен init

### Контекст на процес ###
  Всеки процес има контекст, част от който са някои важни атрибути:
- PID - номер на процеса, по който можем да го идентифицираме
  - Процесът init има PID=1
- PPID - номер на процеса родител на дадения
  - Процесът init има PPID=0
- Nice value - стойност, по която се определя приоритета на процеса
  - по-високо nice value означава по-нисък приоритет
  - между -20 и 19, като за повечето процеси е 0
- Security context (ще говорим за него след малко)
- Памет, която процесът може да достъпва
- Отворени файлове (файлови дескриптори)
- И други

### Security context ###
Всеки процес има няколко атрибута, свързани с потребители и изолация:
- UID, GID - потребител и група, собственици на процеса
- Effective UID, Effective GID - потребител и група, с които процесът се
представя, когато се опитва да работи с някакъв обект
  - обикновено ефективните и реалните потребител и група съвпадат
  - някои специални програми се възползват от това, че могат да бъдат
различни
  - при изпълнение на програма със SUID/SGID бит биха били различни
- и други…

### Състояния на процесите ###
В даден момент един процес може да е в едно от няколко състояния:
- R – running - в опашката с работещи процеси
- D – uninterruptible sleep - чака събитие (обикновено вход/изход на данни) и не може да бъде спрян
- S – interruptible sleep - чака събитие и може да бъде спрян
- T – stopped (job control) - паузиран от потребител
- t – stopped by debugger - паузиран от дебъгер
- Z – defunct (“zombie”) - приключил и чака родителят му да обработи резултата
- и няколко други, които не са важни в момента

### Преглеждане на информация за процесите ###
- Директорията /proc съдържа информация за всички процеси
- За всеки процес има директория /proc/<PID>, в която има виртуални файлове, съдържащи информация за този процес
- Има няколко команди - инструменти, които четат информацията в /proc и я показват в удобен вид
  - $ ps - показва информация за дадени процеси в момента на извикване
  - $ top - показва информация за процесите в интерактивен режим
  - $ pstree - рисува дърво с процесите

### Малко повече за ps ###
По подразбиране изписва данни за процесите в текущия терминал
- $ ps -e изписва данни за всички процеси
- $ ps -u <потребител> изписва данни за процесите на дадения потребител
```
$ ps
PID TTY TIME CMD
14928 pts/4 00:00:00 bash
15353 pts/4 00:00:00 ps

$ ps -e | head -n 5
PID TTY TIME CMD
1 ? 00:00:14 init
2 ? 00:00:00 kthreadd
3 ? 00:00:00 rcu_gp
4 ? 00:00:00 rcu_par_gp

$ ps -u pesho
PID TTY TIME CMD
7557 ? 00:00:00 sshd
7558 pts/6 00:00:00 bash
```
- Опцията -f казва на ps да изписва повече информация
  - $ ps -ef - показва много информация за всички процеси
- С опцията -o можем да включим специфични колонки в изхода на ps
  - $ ps -u pesho -o pid,ppid,cmd - за всеки процес на потребителя pesho, изписва неговия PID, родителски PID и командa

- Можем да именуваме колонките
```
$ ps -e -o user=account,pid=process_id | head -n 4
account process_id
root 1
root 2
root 3
```
- Можем и да скрием хедъра
```
$ ps -e -o user=,pid= | head -n 3
root 1
root 2
root 3
```
### Сигнали ###
| Сигнал  | Описание |  default |
| ------------- | ------------- | ------------- |
| SIGHUP(1) | праща се на процес, когато затворим терминала  |  kill |
| SIGINT(2) |  праща се при Ctrl-C | kill |
| SIGKILL(9) | убива процеса директно; не може да се маскира  |  kill! |
| SIGSEGV(11) |  праща се при непозволен достъп до памет | kill |
| SIGTERM(15) |  убива процеса, но може да се маскира | kill |
| SIGSTOP(19) | паузира процеса | stop/pause! |
| SIGCONT(18)  | продължава паузиран процес | continue! |

- $ kill -<СИГНАЛ> <PID> праща дадения сигнал на дадения процес
  - $ kill -TERM 42 - праща сигнал SIGTERM на процес със номер 42
- $ killall -<СИГНАЛ> <име> праща дадения сигнал на всички процеси с даденото име
  - $ kill -INT bash праща сигнал SIGINT на всички процеси bash
- Ctrl-C в терминала праща SIGINT на текущия процес, а Ctrl-Z праща SIGSTOP
  - за Ctrl-Z и SIGSTOP ще говорим след малко
- Ако не подадем конкретен сигнал, се праща SIGTERM

### Job control ###
- В една терминална сесия може да имаме няколко работещи процеса
едновременно
- Три възможни състояния на всеки процес
  - Foreground (работи и клавиатурата е закачена към stdin на процеса)
  - Background (работи във фонов режим, stdin е откачен)
  - Stopped (паузиран във фонов режим)
- Освен по своя PID, процесите в една терминална сесия се идентифицират и по число, наречено Job ID

- Командата $ jobs показва всички процеси в текущата сесия и техните job ID-та
- Конструкцията $ <команда> & пуска команда във фонов режим
  - командата си работи в отделен процес, а през това време можем да продължим да използваме shell-а
- Ctrl-Z паузира текущо-работещия процес
  - използва SIGSTOP
- Командата $ fg \<job id\> закача фонов процес към терминала
  - ако е бил паузиран, го стартира
- Командата $ bg \<job id\> стартира паузиран працес във фонов режим
